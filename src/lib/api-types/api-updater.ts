import { pathToImportPath, toValidVariable } from '../utils/string.js'
import fs from 'fs'
import { resolve, relative } from 'path'
import { debugging } from '$lib/internal.js'
import type { ZeroAPIPluginConfig } from '$lib/vitePlugin.js'

const cwd = process.cwd()

function deleteNestedEmptyObjects(obj: any) {
	// modify by reference
	Object.keys(obj).forEach(function(key) {
		if (typeof obj[key] === 'object') {
			deleteNestedEmptyObjects(obj[key])
			if (Object.keys(obj[key]).length === 0) {
				delete obj[key]
			}
		}
	})
}
function parsePath(resolutionPath: string, path: string) {
	const _relative = relative(resolutionPath, path).replace('..', '.')
	const importName = pathToImportPath(_relative)
	const alias = toValidVariable(importName)
	return { importName, alias }
}

/** Is run when file changes has been detected */
export function apiUpdater(
	config: ZeroAPIPluginConfig,
	/** Resolved to real path i.e. `src/routes = C:/current/project/src/routes` */
	routesDirectory: string
) {
	type Directory = { [key: string]: string | Directory }
	let apiTypes: Directory = {}
	let importStatements = ''
	debugging && console.time(`[DEBUG] Updated generated types at ${routesDirectory} ...`)
	const { tempOutput, outputDir = 'src' } = config
	const resolution = tempOutput ?
		resolve(cwd, tempOutput) : resolve(cwd, '.svelte-kit', 'types', outputDir, 'sveltekit-zero-api.d.ts')

	function recursiveLoad(dir: string, directory: Directory) {
		const files = fs.readdirSync(dir)

		// ex. src/routes/(app)/api/somedir/index.ts
		for (const fileName of files) {
			const path = resolve(dir, fileName)
			const metadata = fs.statSync(path)

			if (metadata.isDirectory()) {
				if (!directory[fileName])
					directory[fileName] = {}
				recursiveLoad(path, directory[fileName] as Directory)
				continue
			}

			if (!/\+server.(ts|js)/gm.test(fileName))
				continue

			const { alias, importName } = parsePath(resolution, path)
			importStatements += `import * as ${alias} from "${importName}"\n`

			const key = fileName.replace(/\.(ts|js)$/g, '')
			directory[key] = `Z<typeof ${alias}>`
		}
	}
	recursiveLoad(routesDirectory, apiTypes)

	function fixKeys(obj: any) {
		for (let key of Object.keys(obj)) {
			if (typeof obj[key] === 'object')
				obj[key] = fixKeys(obj[key])
			const isGroup = key.startsWith('(') && key.endsWith(')')
			if (!isGroup)
				continue
			let content = obj[key]
			delete obj[key]
			obj = { ...obj, ...content }
		}
		return obj
	}

	deleteNestedEmptyObjects(apiTypes)
	apiTypes = fixKeys(apiTypes)

	let dirText = JSON.stringify(apiTypes, null, 2)
		
	
	dirText = dirText
		// Transform routes into API types
		.replaceAll(/\"\+server\"\: \"Z/g, '} & Z')
		.replaceAll(/(__server\>\",)|(__server\>\")/g, '__server> & {')
		
		// Transform slugs e.g. "[slug]": into functions slug$: (slug: S) =>
		// TODO: Allow ex. [slug].[second] to become slug$second$: (slug: S, second: S) =>
		.replaceAll(/\"\[(.*?)\]\"\:/g, '$1$: ($1: S) =>')
		.replaceAll(/=\w+(?=:|\$)/g, '')
	
	const folder = resolve(resolution, '..')
	if (!fs.existsSync(folder))
		fs.mkdirSync(folder, { recursive: true })
	
	debugging && console.timeEnd(`[DEBUG] Updated generated types at ${resolution} ...`)
	
	try {
		// Flag is required to make it a writeable stream. Replacing file messes with TypeScript.
		fs.writeFileSync(resolution, file(dirText, importStatements), { flag: 'w+' })
	} catch (error) {
		console.warn(error)
	}
}

const file = (dirText: string, importCode: string) =>
	`/* eslint-disable */
/* 
    -- Generated sveltekit-zero-api --
          Do not edit this file
*/
import type { Z } from 'sveltekit-zero-api/types/zeroapi'
${importCode}

type S = string | number 
export type GeneratedAPI = ${dirText}`