import { pathToImportPath, toValidVariable } from '../utils/string.js'
import fs from 'fs'
import { resolve, relative } from 'path'
import { debugging } from '$lib/internal.js'
import type { ZeroAPIPluginConfig } from '$lib/vitePlugin.js'

const cwd = process.cwd()

let running = false

function deleteNestedEmptyObjects(obj: any) {
	// modify by reference
	Object.keys(obj).forEach(function(key) {
		if (typeof obj[key] === 'object') {
			deleteNestedEmptyObjects(obj[key])
			if (Object.keys(obj[key]).length === 0) {
				delete obj[key]
			}
		}
	})
}

function parsePath(resolutionPath: string, path: string) {
	const _relative = relative(resolutionPath, path).replace('..', '.')
	const importName = pathToImportPath(_relative)
	const alias = toValidVariable(importName)
	return { importName, alias }
}

/** Is run when file changes has been detected */
export function apiUpdater(
	config: ZeroAPIPluginConfig,
	/** Resolved to real path i.e. `src/routes = C:/current/project/src/routes` */
	routesDirectory: string
) {
	if (running)
		return
	running = true

	type Directory = { [key: string]: string | Directory }
	let apiTypes: Directory = {}
	let importStatements = ''
	
	
	
	const { tempOutput, outputDir = 'src' } = config
	const resolution = tempOutput ?
		resolve(cwd, tempOutput) : resolve(cwd, outputDir, 'sveltekit-zero-api.d.ts')

	debugging && console.time(`[DEBUG] Updated generated types at ${resolution} ...`)
	
	function recursiveLoad(dir: string, directory: Directory) {
		const files = fs.readdirSync(dir)

		// ex. src/routes/(app)/api/somedir/index.ts
		for (let fileName of files) {
			const path = resolve(dir, fileName)
			const metadata = fs.statSync(path)

			if (metadata.isDirectory()) {
				if (!directory[fileName]){
					if(fileName.match(/\[(.*?)\]/)){
						// this should be a promise, it should resolve when dirText is parsed...
						const { alias } = parsePath(resolution, path + '\\+server.ts') // comply with pathToImportPath
						fileName = fileName.replace(/\[(.*?)\]/, `[$1]${alias}`)
					}
					directory[fileName] = {}
				}
				recursiveLoad(path, directory[fileName] as Directory)
				continue
			}

			if (!/\+server.(ts|js)/gm.test(fileName))
				continue

			const { alias, importName } = parsePath(resolution, path)
			importStatements += `import * as ${alias} from "${importName}"\n`

			const key = fileName.replace(/\.(ts|js)$/g, '')
			directory[key] = `Z<typeof ${alias}>`
		}
	}
	recursiveLoad(routesDirectory, apiTypes)

	function fixKeys(obj: any) {
		for (let key of Object.keys(obj)) {
			if (typeof obj[key] === 'object')
				obj[key] = fixKeys(obj[key])
			const isGroup = key.startsWith('(') && key.endsWith(')')
			if (!isGroup)
				continue
			let content = obj[key]
			delete obj[key]
			obj = { ...obj, ...content }
		}
		return obj
	}

	deleteNestedEmptyObjects(apiTypes)
	apiTypes = fixKeys(apiTypes)

	let dirText = JSON.stringify(apiTypes, null, 2)
	
	dirText = dirText
		// Transform routes into API types
		.replaceAll(/\"\+server\"\: \"Z/g, '} & Z')
		.replaceAll(/(__server\>\",)|(__server\>\")/g, '__server> & {')
		
		// Transform slugs e.g. "[slug]": into functions slug$: (slug: S) =>
		// TODO: Allow ex. [slug].[second] to become slug$second$: (slug: S, second: S) =>
		.replaceAll(/\"\[(.*?)\](.*?)\"\:/g, (match, p1, p2) => {
			// FIXME: check for other cases
			const alias = p2 || '{}';
			return `${p1}$: (${p1}: Slug<typeof ${alias}>) =>`;
		})
		.replaceAll(/=\w+(?=:|\$)/g, '')

	const folder = resolve(resolution, '..')
	if (!fs.existsSync(folder))
		fs.mkdirSync(folder, { recursive: true })
	
	debugging && console.timeEnd(`[DEBUG] Updated generated types at ${resolution} ...`)
	
	try {
		// Flag is required to make it a writeable stream. Replacing file messes with TypeScript.
		fs.writeFileSync(resolution, file(dirText, importStatements), { flag: 'w+' })
	} catch (error) {
		console.warn(error)
	}

	running = false
}

/**
 * This is required because for some reason,
 * "sveltekit-zero-api" becomes "../../../dist/types/zeroapi",
 * when developing sveltekit-zero-api and is an incorrect path.
*/
const z = debugging ?
	`import type { Z } from '../../dist/types/zeroapi'`
	:
	`import type { Z } from 'sveltekit-zero-api/types/zeroapi'`

const file = (dirText: string, importCode: string) =>
	`/* eslint-disable */
/* 
    -- Generated sveltekit-zero-api --
          Do not edit this file
*/
${z}
${importCode}

type Slug<Module> = Module extends { Slug: infer S } ? S : string | number

export type GeneratedAPI = ${dirText}`